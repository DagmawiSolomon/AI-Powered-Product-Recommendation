import { GoogleGenAI } from "@google/genai";
import { Id } from "../_generated/dataModel";
import { Doc } from "../_generated/dataModel";


export function cleanAIJson(raw: string): string {
  if (!raw) return "";

  let text = raw;

  // Remove Markdown code fences ```json ... ```
  text = text.replace(/```(?:json)?/gi, "");

  // Remove any stray "undefined" or other trailing words
  text = text.replace(/\bundefined\b/gi, "");

  // Remove trailing commas before } or ]
  text = text.replace(/,\s*(\}|\])/g, "$1");

  // Trim leading/trailing whitespace
  text = text.trim();

  // Keep only text within first {...} block (helps if LLM adds extra commentary)
  const match = text.match(/\{[\s\S]*\}/);
  if (match) text = match[0];

  return text;
}

type input = {
  query: string;
  products: {
    name: string;
    price: number;
    description: string;
    tags: string[];
    reasoning: string;
  }[];
};

const instruction_prompt = `You are an AI comparison engine. Your task is to create a **brief comparison string** between products based on how well they fit the user’s query.

### Inputs:
- User query: <string>
- Products array: each object contains:
  {
    "name": <product name>,
    "description": <product description>,
    "tags": <array of tags>,
    "price": <product price>,
    "reasoning": <reasoning previously generated by AI for this product>
  }

### Output Format:
- Strictly **valid JSON only**, with a single field "comparison":
{
  "comparison": "Product A fits your needs well but I notice it lacks full noise cancellation; Product B is great for commuting but slightly over budget; Product C offers comfort but fewer advanced features."
}

### Rules / Tone:
1. Phrase the **comparison string in first-person**, as if the AI is explaining the pros and cons directly to the user.  
2. Include any relevant **negatives or trade-offs**, referencing the precomputed "reasoning" field.  
3. Be **concise, clear, and focused on how well each product fits the user's prompt**.  
4. Only use **provided metadata** (name, description, tags, price) and existing reasoning. Do not hallucinate or invent new attributes.  
5. Output **must be valid JSON**, with only the "comparison" field. No extra text.
6. If the search doesn't match any of the products passed clearly say "No product found that matches ur search" don't return unnessary explations


### Additional Notes:
- The comparison should **summarize the top products in 1–2 sentences each**, joined into a single string.  
- Focus on relevance to the user query rather than general product praise.
`;

export async function generateComparisonText(input: input) {
  const apiKey = process.env.GOOGLE_GEMINI_API_KEY;
  if (!apiKey) throw new Error("GOOGLE_GEMINI_API_KEY environment variable not set!");

  const ai = new GoogleGenAI({ apiKey });
  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: `
      ${instruction_prompt}
      ### Inputs:
      - User query: ${input.query}
      - Products array ${input.products.map((p) => JSON.stringify(p))}
    `,
    config: { temperature: 0.15 },
  });

  if (!response.text) throw new Error("No response text from AI");

  let parsed: { comparison: string };

  try {
    const cleanedText = cleanAIJson(response.text);
    const safeText = cleanedText
      .replace(/\\'/g, "'") 
      .replace(/[\u0000-\u001F]+/g, ""); 

    parsed = JSON.parse(safeText);

    
    if (
      !parsed ||
      typeof parsed.comparison !== "string" ||
      Object.keys(parsed).length !== 1
    ) {
      throw new Error(
        "Parsed output must be a single-field object with a string 'comparison'"
      );
    }
  } catch (err: any) {
    console.error("LLM output validation failed:", err.message);
    throw new Error(`LLM output invalid: ${err.message}`);
  }

  return parsed;
}
